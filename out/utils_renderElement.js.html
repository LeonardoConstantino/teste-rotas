<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>JSDoc: Source: utils/renderElement.js</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link
      type="text/css"
      rel="stylesheet"
      href="styles/prettify-tomorrow.css"
    />
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css" />
  </head>

  <body>
    <div id="main">
      <h1 class="page-title">Source: utils/renderElement.js</h1>

      <section>
        <article>
          <pre class="prettyprint source linenums"><code>/**
 * Renderiza um elemento HTML no contêiner especificado.
 *
 * @param {Object} elementConfig - Configuração do elemento a ser renderizado.
 * @param {string|null} elementConfig.type - Tipo de elemento HTML (e.g., 'div', 'span') ou null para nós de texto.
 * @param {Object} [elementConfig.props={}] - Propriedades do elemento HTML.
 * @param {string|number} [elementConfig.props.nodeValue] - Valor do nó de texto (se aplicável).
 * @param {Array&lt;Object>} [elementConfig.props.children] - Filhos do elemento HTML.
 * @param {boolean} [isAppend=false] - Indica se o elemento deve ser adicionado ao contêiner.
 * @param {HTMLElement} [container=document.body] - Contêiner onde o elemento será inserido.
 * @returns {HTMLElement|Text|undefined} - Retorna o elemento criado se `isAppend` for falso.
 * @throws {Error} Se o tipo do elemento for inválido.
 * @throws {Error} Se um valor de atributo for inválido.
 * @throws {Error} Se um listener de evento for inválido.
 * @throws {Error} Se os filhos não forem um array.
 * @example
 *
 * // Exemplo de uso
 * const myElement = {
 *   type: 'button',
 *   props: {
 *     type: 'button',
 *     className: 'btn',
 *     onClick: () => alert('Clicked'),
 *     children: [{ type: null, props: { nodeValue: 'Click me' } }]
 *   }
 * };
 *
 * // Renderiza o elemento no corpo do documento
 * renderElement(myElement, true);
 */
export const renderElement = (
  { type, props = {} },
  isAppend = false,
  container = document.body
) => {
  try {
    // Validação de tipo de elemento
    if (type !== null &amp;&amp; type !== undefined &amp;&amp; typeof type !== 'string') {
      throw new Error(`Invalid element type: ${type}`)
    }

    // Determina se é um nó de texto
    const isTextElement = type === undefined || type === null
    const element = isTextElement
      ? document.createTextNode(props.nodeValue || '')
      : document.createElement(type)

    if (!isTextElement) {
      /**
       * Verifica se a propriedade é um listener de evento.
       * @param {string} p - Nome da propriedade.
       * @returns {boolean} - Verdadeiro se a propriedade for um listener de evento.
       */
      const isListener = (p) => p.startsWith('on')

      /**
       * Verifica se a propriedade é um atributo HTML.
       * @param {string} p - Nome da propriedade.
       * @returns {boolean} - Verdadeiro se a propriedade for um atributo HTML.
       */
      const isAttribute = (p) =>
        !isListener(p) &amp;&amp; p !== 'children' &amp;&amp; p !== 'nodeValue'

      // Itera sobre as propriedades do elemento
      Object.keys(props).forEach((p) => {
        if (isAttribute(p)) {
          if (typeof props[p] !== 'string' &amp;&amp; typeof props[p] !== 'number') {
            throw new Error(`Invalid attribute value for ${p}: ${props[p]}`)
          }
          element.setAttribute(p, props[p])
        }
        if (isListener(p)) {
          if (typeof props[p] !== 'function') {
            throw new Error(`Invalid event listener for ${p}: ${props[p]}`)
          }
          element.addEventListener(p.toLowerCase().slice(2), props[p])
        }
      })

      // Renderiza os filhos, se houver
      const children = props.children || []
      if (!Array.isArray(children)) {
        throw new Error(`Children should be an array: ${children}`)
      }
      children.forEach((childElement) =>
        renderElement(childElement, true, element)
      )
    }

    if (isAppend) {
      // Adiciona o elemento ao contêiner
      container.appendChild(element)
      return element
    }
    return element
  } catch (error) {
    console.error('Error rendering element:', error.message)
  }
}
</code></pre>
        </article>
      </section>
    </div>

    <nav>
      <h2><a href="index.html">Home</a></h2>
      <h3>Global</h3>
      <ul>
        <li><a href="global.html#autor">autor</a></li>
        <li>
          <a href="global.html#capitalizeFirstLetter">capitalizeFirstLetter</a>
        </li>
        <li><a href="global.html#createButton">createButton</a></li>
        <li><a href="global.html#createFooter">createFooter</a></li>
        <li><a href="global.html#createHeader">createHeader</a></li>
        <li><a href="global.html#createNavigation">createNavigation</a></li>
        <li><a href="global.html#currentYear">currentYear</a></li>
        <li><a href="global.html#getComponent">getComponent</a></li>
        <li><a href="global.html#getHeader">getHeader</a></li>
        <li><a href="global.html#getPage">getPage</a></li>
        <li><a href="global.html#getSection">getSection</a></li>
        <li><a href="global.html#getTextComponent">getTextComponent</a></li>
        <li><a href="global.html#hrefList">hrefList</a></li>
        <li><a href="global.html#icone">icone</a></li>
        <li><a href="global.html#loadNotFound">loadNotFound</a></li>
        <li><a href="global.html#matchRoute">matchRoute</a></li>
        <li><a href="global.html#navigateTo">navigateTo</a></li>
        <li><a href="global.html#pathToRegex">pathToRegex</a></li>
        <li><a href="global.html#paths">paths</a></li>
        <li><a href="global.html#renderElement">renderElement</a></li>
        <li><a href="global.html#router">router</a></li>
        <li><a href="global.html#routes">routes</a></li>
        <li><a href="global.html#setRouter">setRouter</a></li>
      </ul>
    </nav>

    <br class="clear" />

    <footer>
      Documentation generated by
      <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.3</a> on Mon Jun 24
      2024 22:02:08 GMT-0300 (Horário Padrão de Brasília)
    </footer>

    <script>
      prettyPrint()
    </script>
    <script src="scripts/linenumber.js"></script>
  </body>
</html>
